<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Основы ООП и другие пасты — PHP с нуля</title>
    <link rel="apple-touch-icon" href="../phpbook-favicon-128.png">
        <link rel="shortcut icon" href="../favicon.ico">
    <link rel="icon" type="image/vnd.microsoft.icon" href="../favicon.ico" sizes="32x32">
    <link rel="icon" type="image/png" href="../phpbook-favicon-128.png" sizes="128x128">
    <link rel="icon" type="image/png" href="../phpbook-favicon-64.png" sizes="64x64">
    <link href="../style.css" type="text/css" rel="stylesheet">
</head>
<body>
    <div class="l-content-wrap">
        <div class="l-content">



            <h1 class="lifted-up">Основы ООП и другие пасты</h1>
    
    <div class="b-teaser"><p>Здесь выложены черновики не написанных пока уроков.</p></div>

    <h2>Объекты в PHP</h2>

<p>В этом уроке мы узнаем, что такое объекты и классы, как их использовать и для чего они нужны.</p>

<p>Как ты, помнишь, в PHP существуют данные разных типов: числа, строки, а также массивы. Еще один тип — это объекты.</p>

<p><em>Объект</em> — это такая штука, которая содержит внутри себя переменные (они называются поля, свойства или члены) и функции (которые называют <em>методами</em>). Каждый объект относится к определенному <em>классу</em> (виду). Класс определяет, какие именно поля и методы есть в объекте, например «все объекты класса X имеют поля field1, field2 и field3». Классы описывает программист, то есть ты.</p>

<p>Порядок работы с объектами такой:</p>

<ol>
<li>Определяем (объявляем, создаем) класс. При этом мы описываем какие поля и методы будут у объектов этого класса.</li>
<li>Создаем один или несколько объектов этого класса</li>
<li>Используем их для решения задачи</li>
</ol>

<p>Объекты используются обычно для того, чтобы хранить свойства каких-то сущностей (предметов), с которыми работает программа. В этом уроке мы напишем программу для проверки знаний, которая умеет задавать вопросы и считать число правильных ответов. Нам надо как-то хранить в ней список вопросов, варианты ответов, число баллов за правильный ответ.</p>

<p>Объекты можно хранить в переменной, помещать в массив, передавать в функцию, возвращать из функций - в общем, делать все то же самое, что и с другими типами значений вроде чисел или массивов.</p>

<p>Попробуем для этого описать класс <code>Question</code> (Вопрос), объекты которого будут хранить в себе все это (один объект соответствует одному вопросу, такой объект еще иногда называют <em>моделью</em> вопроса). </p>

<p>Итак, у нас есть сущность «Вопрос» и у нее есть такие свойства: «текст вопроса», «число баллов за правильный ответ», «варианты ответов», «правильный ответ». Опишем соответствующий класс:</p>

<pre><code>class Question
{
    public $text;           // текст вопроса
    public $points = 5;     // число баллов, по умолчанию 5
    public $answers;        // варианты ответов
    public $correctAnswer;  // правильный ответ
}
</code></pre>

<p>Этот код объявляет новый класс <code>Question</code> и определяет, что у всех объектов этого класса есть свойства <code>text</code>, <code>points</code>, <code>answers</code> и <code>correctAnswers</code>. Слово «public» обозначает, что эти свойства объекта можно читать и менять из любого места программы (доступ к свойству объекта можно ограничить, но это мы изучим позже). Также, мы указали, что свойство <code>$points</code> имеет значение по умолчанию 5. У остальных свойств значение по умолчанию не указано, и при создании нового объекта им будет присвоено значение <code>null</code> (если ты с ним раньше не сталкивался, то <code>null</code> - это специальное значение, которое обозначает отстутствие какого-либо значения. <a href="http://php.net/manual/ru/language.types.null.php">Мануал по null</a>).</p>

<p>В общем, для объявления (создания) класса используется ключевое слово <code>class</code>: </p>

<pre><code>class ИмяКласса
{
    список полей и методов в классе;
}
</code></pre>

<p>Имя класса принято писать с большой буквы. Точку с запятой после закрывающей фигурной скобки ставить не надо (как и с функциями). У каждого класса должно быть уникальное имя, при попытке создать класс с таким же именем во второй раз будет ошибка: </p>

<pre><code>class A { }
class A { }  // в этом месте произойдет ошибка 
</code></pre>

<p>Сам по себе этот код только объявляет класс и больше ничего не делает. Давай теперь создадим несколько объектов класса Question и заполним их поля полезными значениями.</p>

<p>Вот что примерно мы хотим получить в итоге: несколько объектов с вопросами и ответами.</p>

<p><img src="../i/l1/pasta/classes-objects.png" alt="Классы и объекты с вопросами"></p>

<p>Объект создается с помощью <dfn>оператора создания нового объекта</dfn> <code>new</code>, после которого надо указать, какого класса объект мы хотим создать. </p>

<pre><code>// Создадим три объекта (так как у нас будет 3 вопроса в тесте), и сохраним их в трех переменных:
$q1 = new Question;
$q2 = new Question;
$q3 = new Question;

// Выведем содержимое первого объекта
var_dump($q1);
</code></pre>

<p>Посмотреть этот код в действии: <a href="http://ideone.com/l9S0eb">http://ideone.com/l9S0eb</a>. Он выводит что-то вроде этого: </p>

<pre><code>object(Question)#1 (4) {
  ["text"]=&gt; NULL
  ["points"]=&gt; int(5)
  ["answers"]=&gt; NULL
  ["correctAnswer"]=&gt; NULL
}
</code></pre>

<p>Написан класс, к которому относится объект, порядковый номер и значения полей. Когда мы создаем новый объект, всем его полям присваивается либо значение по умолчанию (например, у поля <code>points</code> это 5), либо, если оно не указано, то значение null. Обратиться к полю объекта можно с помощью оператора <code>-&gt;</code>, напоминающего стрелочку, состоящего из знака минус и угловой скобки. Слева пишется переменная, хранящая объект, а справа — имя поля. Используется он так:</p>

<pre><code>$object-&gt;field = 4;
</code></pre>

<p>Обрати внимание, что доллар перед словом <code>field</code> писать не надо, если ты напишешь <code>$object-&gt;$field</code>, то будет ошибка (будет обращение не к полю <code>field</code>, а к полю, имя которого хранится в переменной <code>$field</code>).</p>

<p>Давай теперь заполним наши объекты вопросами и ответами. Поскольку у одного вопроса может быть несколько ответов, то мы используем массив для их хранения:</p>

<pre><code>// Вопрос 1
$q1 = new Question;
$q1-&gt;text = "Какая планета располагается четвертой по счету от Солнца?";
$q1-&gt;points = 10; // 10 баллов за ответ
$q1-&gt;answers = array('a' =&gt; 'Венера', 'b' =&gt; 'Марс', 'c' =&gt; 'Юпитер', 'd' =&gt; 'Меркурий'); // Варианты ответа
$q1-&gt;correctAnswer = 'b'; // Правильный ответ

// Вопрос 2
$q2 = new Question;
$q2-&gt;text = 'Какой город является столицей Великобритании?';
$q2-&gt;points = 5;
$q2-&gt;answers = array('a' =&gt; 'Париж', 'b' =&gt; 'Москва', 'c' =&gt; 'Нью-Йорк', 'd' =&gt; 'Лондон');
$q2-&gt;correctAnswer = 'd';

// Вопрос 3
$q3 = new Question;
$q3-&gt;text = 'Кто придумал теорию относительности?';
$q3-&gt;points = 30;
$q3-&gt;answers = array('a' =&gt; 'Джон Леннон', 'b' =&gt; 'Джим Моррисон', 'c' =&gt; 'Альберт Эйнштейн', 'd' =&gt; 'Исаак Ньютон');
$q3-&gt;correctAnswer = 'c';

// Выведем содержимое, чтобы проверить, что все верно
var_dump($q1, $q2, $q3);
</code></pre>

<p>Посмотреть код целиком: <a href="http://ideone.com/FWJuCV">http://ideone.com/FWJuCV</a></p>

<p>Объект чем-то напоминает массив (в котором тоже может содержаться много элементов: <code>$q = ['text' =&gt; ...., 'points' =&gt; 10, ....]</code>), но разница в том, что работая с объектом, ты точно знаешь какие поля там есть. Также, объекты относятся к тому или иному классу и по его названию понятно что хранится в объекте. А в случае с массивом ты должен искать в программе место, где он был создан, и изучать код. В больших программах (а реальные приложения очень большие) это требует много времени, потому c объектами работать намного удобнее. Вообще, объекты как раз и были придуманы для того, чтобы было можно писать большие приложения и не запутаться.</p>

<p>Ок, мы объявили класс, создали 3 объекта с вопросами. Теперь надо их вывести. Прежде чем писать код, давай сделаем небольшое улучшение: заводить на каждый вопрос новую переменную — неудобно, со временем мы можем сбиться и перепутать их номера. Давай лучше сделаем массив и будем добавлять объекты-вопросы в него по одному. Второе улучшение — мы завернем код создания объектов в функцию, так как наша программа становится большой и надо разбивать ее на отдельные части, чтобы не превратить в длинную нечитаемую портянку. Функция создает 3 объекта-Вопроса, кладет их в массив и возвращает его. Вот, что выходит в итоге:</p>

<pre><code>// Функция, создающая массив с вопросами:
function createQuestions()
{
    // Создаем пустой массив
    $questions = [];

    // Создаем и заполняем первый объект
    $q = new Question;
    $q-&gt;text = ...
    ...
    // Кладем вопрос в массив
    $questions[] = $q;

    // Создаем второй объект
    $q = new Question;
    ...

    return $questions;
}
</code></pre>

<p>Теперь мы можем продолжить. Давай напишем функцию, выводящую список вопросов с вариантами ответов. На вход функции, естественно, надо дать массив с вопросами. Используем цикл для обходя всех вопросов и выведем для каждого текст и варианты ответов (для вывода ответов используем вложенный цикл):</p>

<pre><code>function printQuestions($questions)
{
    $number = 1; // номер вопроса

    foreach ($questions as $question) {
        echo "{$number}. {$question-&gt;text}\n\n";

        echo "Варианты ответов:\n";

        foreach ($question-&gt;answers as $letter =&gt; $answer) {
            echo "  {$letter}. {$answer}\n";
        }

        $number++; 
    }
}
</code></pre>

<p>Теперь осталось создать объекты-вопросы, вызвав первую функцию, и вывести их с помощью второй:</p>

<pre><code>$questions = createQuestions();
printQuestions($questions);
</code></pre>

<p>Прекрасно! Давай теперь напишем еще и код для проверки ответов и выставления баллов. Было бы хорошо сделать интерактивный тест (который выводит вопросы и ждет, пока пользователь введет ответы), но так как мы используем ideone, то сделать это сложно, потому для простоты давай предположим, что мы уже собрали ответы и поместили их в массив. Пусть, например, массив содержит буквы a-d для каждого вопроса: </p>

<pre><code>$answers = array('b', 'd', 'a');
</code></pre>

<p>Мы хотим проверить ответы, посчитать число баллов и вывести вопросы, на который дан неправильный ответ. Очевидно, нам для этого нужна еще одна функция (мы ведь не хотим писать код сплошной стеной). Она получает на вход массив вопросов и массив ответов. </p>

<pre><code>function checkAnswers($questions, $answers)
{
    // Проверим, что число ответов равно числу вопросов (защищаемся от ошибки)
    if (count($questions) != count($answers)) {
        die("Число ответов и вопросов не совпадает\n");
    }

    $pointsTotal = 0; // сколько набрано баллов

    // сколько можно набрать баллов при всех правильных ответах
    $pointsMax = 0;  
    // сколько отвечено верно
    $correctAnswers = 0; 

    $totalQuestions = count($questions); // Сколько всего вопросов

    // Цикл для обхода вопросов и ответов
    for ($i = 0; $i &lt; count($questions); $i++) {
        $question = $questions[$i]; // Текущий вопрос
        $answer = $answers[$i]; // текущий ответ

        // Считаем максимальную сумму баллов
        $pointsMax += $question-&gt;points;

        // Проверяем ответ
        if ($answer == $question-&gt;correctAnswer) {
            // Добавляем баллы
            $correctAnswers ++;
            $pointsTotal += $question-&gt;points;
        } else {
            // Неправильный ответ
            $number = $i + 1;
            echo "Неправильный ответ на вопрос №{$number} ({$question-&gt;text})\n";
        }
    }

    // Выведем итог
    echo "Правильных ответов: {$correctAnswers} из {$totalQuestions}, баллов набрано: ? из ?\n";
}
</code></pre>

<p>Ну и теперь надо вызвать эту функцию, чтобы проверить ответы:</p>

<pre><code>$questions = createQuestions();
printQuestions($questions);
$answers = array('b', 'd', 'a');
checkAnswers($questions, $answers);
</code></pre>

<p>Запустим программу (это ты должен сделать сам).</p>

<p>Ты можешь спросить, почему она пишет знаки вопроса вместо числа баллов? Хе-хе, потому что это часть домашнего задания для тебя, которое поможет закрепить тебе знания. Собственно, вот и задача: </p>

<ol>
<li>доработай программу, чтобы она выводила набранное число баллов и максимально возможное вместо знаков вопроса.</li>
<li>сделай функцию в программе, чтобы у каждого вопроса была подсказка и при неправильном ответе выводилась эта подсказка. Тебе для этого понадобится добавить в класс еще одно поле, в котором она будет храниться.</li>
</ol>

    <h2>Объекты в PHP, часть 2</h2>

<p>В прошлом уроке мы разобрались с тем, что такое объекты и классы. В этом уроке мы продолжим их изучать.</p>

<p>Кроме полей, в классе можно объявить еще методы. Методы — это функции для работы с объектом. Попробуем разобрать, как они объявляются и используются, на примере. </p>

<p>В этом уроке примером будет программа для расчета зарплаты сотрудников международной динамично развивающейся компании «Вектор». Допустим, у нас есть список сотрудников, известно, сколько они отработали часов в каждую неделю, известа их почасовая оплата, требуется посчитать для каждого общее число часов и зарплату и вывести в такой табличке: </p>

<pre><code>Сотрудник          Часы   Ставка     З/п

Иванов И.           160       10    1600
Петров П.           140        8    1120

Всего               300             2720
</code></pre>

<p>Как и в прошлый раз, начнем с объявления класса, в котором опишем поля с информацией о сотруднике:</p>

<pre><code>class Employee              // employee значит «сотрудник»
{
    public $name;               // имя-фамилия
    public $rate;               // часовая ставка (сколько он получает тугриков за час работы)
    public $hours = array();    // массив, содержащий отработанные часы по неделям
}
</code></pre>

<p>Хорошо, у нас есть класс, создадим пару объектов-сотрудников и сразу же сложим их в массив:</p>

<pre><code>$ivan = new Employee;
$ivan-&gt;name = "Иванов Иван";
$ivan-&gt;rate = 10;    // Иван работает за 10 тугриков в час
$ivan-&gt;hours = array(40, 40, 40, 40);   // Иван работает по 40 часов в неделю

$peter = new Employee;
$peter-&gt;name = "Петров Петр";
$peter-&gt;rate = 8;
$peter-&gt;hours = array(40, 10, 40, 50);  // Петр взял отгул и потому отработал меньше часов, 
                                        // но в  последнюю неделю решил поработать побольше

$employees = array($ivan, $peter);
</code></pre>

<p>Посмотреть код целиком: <a href="http://ideone.com/7Y3SDw">http://ideone.com/7Y3SDw</a></p>

<p>Чудесно (обрати внимание, как легко пишется и аккуратно выглядит код с использованием ООП), у нас есть массив работников. Если надо, мы легко можем добавить туда еще несколько человек. Теперь надо пройтись по нему циклом и для каждого сотрудника посчитать общее число часов и зарплату.</p>

<p>В этом нам помогут методы (метод — это функция, объявленная внутри класса). Как и поля, методы описываются внутри класса. Давай добавим туда методы, которые будут считать эти величины. Для этого надо дописать в класс Employee несколько функций:</p>

<pre><code>class Employee             
{
    public $name;               // имя-фамилия
    public $rate;               // часовая ставка (сколько он получает тугриков за час работы)
    public $hours = array();    // массив, содержащий отработанные часы по неделям

    /** Считает общее число отработанных часов */
    public function getTotalHoursWorked()
    {
        // Просто складываем значения часов в массиве
        return array_sum($this-&gt;hours);
    }

    /** Считает зарплату */
    public function getSalary()
    {
        // Получаем число отработанных часов
        $hours = $this-&gt;getTotalHoursWorked();
        // и умножаем на часовую ставку
        $salary = $hours * $this-&gt;rate;
        return $salary;
    }
}
</code></pre>

<p>Метод, как ты видишь, объявляется как обычная функция, перед которой стоит слово public. Обрати внимание, после закрывающей скобки <code>}</code> не ставится точка с запятой (иначе будет ошибка). Метод вызывается с помощью оператора, напоминающего стрелку, <code>-&gt;</code>, слева пишется объект, справа — имя метода и скобки:</p>

<pre><code>echo "Иван отработал " . $ivan-&gt;getTotalHoursWorked() . " часов\n";
</code></pre>

<p>В общем, вызов метода выглядит так же, как обращение к полю объекта, только добавляются скобки. Также, в методе можно использовать специальную псевдопеременную <code>$this</code>. Она хранит указатель на объект, на котором был вызван метод. Если мы напишем:</p>

<pre><code>echo $ivan-&gt;getTotalHoursWorked();
</code></pre>

<p>То внутри метода getHoursWorked() <code>$this</code> будет указывать на <code>$ivan</code>, и <code>$this-&gt;hours</code> соответственно получает поле <code>hours</code> у объекта <code>$ivan</code>. Если же мы вызовем этот же метод на другом объекте: </p>

<pre><code>echo $peter-&gt;getTotalHoursWorked();
</code></pre>

<p>То в этот раз <code>$this</code> будет указывать на <code>$peter</code> и функция будет считать часы Петра. Ок, теперь попробуем использовать методы для вывода полезной информации:</p>

<pre><code>foreach ($employees as $employee) {
    echo "Имя: {$employee-&gt;name}\n";
    echo "Ставка, тугриков в час: {$employee-&gt;rate}\n";
    echo "Отработал, часов: {$employee-&gt;getTotalHoursWorked()}\n";
    echo "Заработал, тугриков: {$employee-&gt;getSalary()}\n";
}
</code></pre>

<p>Код полностью: <a href="http://ideone.com/v0C99M">http://ideone.com/v0C99M</a></p>

<p>Кроме обычных методов, есть и так называемые «волшебные» методы, их имена начинаются с 2 подчеркиваний. Один из таких методов — это конструктор <code>__construct</code> (другие волшебные методы мы оставим на потом). Этот метод, если он объявлен в классе, автоматически вызывается при создании объекта. Например, с его помощью мы можем создавать не пустые объекты, а сразу при создании указать имя сотрудника и ставку. Вот, как выглядит класс с конструктором: </p>

<pre><code>class Employee             
{
    public $name;               // имя-фамилия
    public $rate;               // часовая ставка (сколько он получает тугриков за час работы)
    public $hours = array();    // массив, содержащий отработанные часы по неделям

    public function __construct($name, $rate)
    {
        // задаем имя и часовую ставку
        $this-&gt;name = $name;
        $this-&gt;rate = $rate;
    }

    .....
}
</code></pre>

<p>Если у класса есть конструктор, то при создании объекта после new и имени класса мы обязаны указать в скобках аргументы ($name и $rate) для этого конструктора:</p>

<pre><code>$ivan = new Employee("Иванов Иван", 10);
// name и rate заданы через конструктор, потому осталось лишь написать часы
$ivan-&gt;hours = array(40, 40, 40, 40);   // Иван работает по 40 часов в неделю

$peter = new Employee("Петров Петр", 8);
$peter-&gt;hours = array(40, 10, 40, 50);
</code></pre>

<p>Вот код с конструкторами целиком: <a href="http://ideone.com/VV8hib">http://ideone.com/VV8hib</a></p>

<p>Благодаря использованию конструктора, мы гарантируем, что у всех объектов-сотрудников будет указано имя и ставка. Если вдруг ты забудешь передать их при вызове <code>new</code>, то интерпретатор PHP выведет сообщение об ошибке. Ну и тот, кто захочет использовать твой класс, сразу увидит, какие аргументы обязательны для создания объекта. Поле <code>hours</code> мы не заполняем через конструктор, так как это необязательное поле и у работника вполне может быть пустой массив отработанных часов.</p>

<p>Задача конструктора - инициализировать все нужные для работы объекта поля. После его завершения объект готов к использованию.</p>

<p>Осталось сделать вывод в виде аккуратной таблички. Для этого нам понадобится написать функции padLeft($string, $length), которая будет дополнять строку $string пробелами слева, если она короче чем $length символов и padRight($string, $length), которая добавляет пробелы справа. Это нужно, чтобы значения в таблице оказались ровно друг над другом.</p>

<pre><code>// Ширина колонок
$col1 = 30;
$col2 = 8;
$col3 = 8;
$col4 = 8;

// Заголовок таблицы
echo padRight("Сотрудник", $col1) .
     padLeft("Часы", $col2) . 
     padLeft("Ставка", $col3) . 
     padLeft("З/п", $col4) . "\n\n";

// Сама таблица
foreach ($employees as $employee) {
    echo padRight($employee-&gt;name, $col1) .
         padLeft($employee-&gt;getTotalHoursWorked(), $col2) . 
         padLeft($employee-&gt;rate, $col3) . 
         padLeft($employee-&gt;getSalary(), $col4) . "\n";
}
</code></pre>

<p>Внимательный читатель может спросить, почему бы не использовать для вывода функцию вроде <code>printf</code> или <code>sprintf</code>, которая позволяет выводить данные в заданном формате, с выравниванием? Очень просто, эти функции, к сожалению, работают только с латинницей, и не поддерживают utf-8, а значит и русские буквы, потому приходиться выкручиваться.</p>

<p>Ты наверно, заметил, что код не дописан. Дописать его — и есть твоя задача на сегодня:</p>

<ol>
<li><p>Допиши код, используя конструкторы, напиши недостающие функции padLeft/padRight, сделай вывод колонки «Всего». Не переусложняй код, там достаточно использовать 2 функции <code>mb_strlen</code> и <code>str_repeat</code>.</p></li>
<li><p>Также, сделай, чтобы выводилось не полное имя, а только фамилия  и первая буква имени. Для этого надо будет добавить в класс метод <code>getShortName()</code>, который будет возвращать имя в нужном виде (например, с помощью <code>preg_replace</code>). При этом значение поля <code>name</code> менять не надо.</p></li>
<li><p>Усовершенствуй программу. Поскольку компания «Вектор» строго соблюдает закон, то она платит своим сотрудникам за овертайм (переработки) двойную ставку. Овертайм — это когда за неделю сотрудник отработал больше 40 часов. Например, Петр в последнюю неделю отработал 50 часов, их них 40 часов оплачиваются по обычной ставке, а 10 часов овертайма — по двойной. Для учета этого, добавь в класс методы getNormalHours() и getOvertimeHours(), и используй их при расчете зарплаты. Таблица должна при этом выглядеть как-то так:</p>

<pre><code>Сотрудник          Часы  Овертайм   Ставка     З/п
Иванов И.           160         0       10    1600
Петров П.           140        10        8    1200
Всего               300        10             2800
</code></pre></li>
</ol>

<h2>Копирование и клонирование объектов</h2>

<p>Объекты можно хранить в переменных, массивах, передавать в функции  и возвращать из функций. Но у них есть одна особенность, которой нет у других типов данных. Когда ты передаешь в функцию или копируешь в другую переменную строку или массив, создается новая копия. Если ты изменишь что-то в ней, исходная переменная не меняется: </p>

<pre><code>$a = ['x' =&gt; 1, 'y' =&gt; 2];
$b = $a;        // происходит клонирование массива
$b['x'] = 10;   // мы меняем только копию в $b, 
                // $a остается неизменной
echo $a['x']; // выведет 1
</code></pre>

<p>Копирование объектов работает по-другому. В переменных хранится не сам объект, а лишь его идентификатор, по которому его можно найти. Соответственно при копировании значения мы просто копируем указатель на тот же самый объект: </p>

<pre><code>class Example 
{
    public $value;
}
$a = new Example;
$a-&gt;value = 1;
$b = $a; // В $b находится указатель на тот же объект
$b-&gt;value = 2; 
echo $a-&gt;value; // выведет 2
</code></pre>

<p>Если ты сделаешь <code>var_dump()</code>, то ты увидишь что объекты в $a и $b имеют один и тот же порядковый номер.</p>

<p>То же самое происходит при передаче объекта в функцию - передается лишь указатель на него и функция может изменять исходный объект. Если ты копируешь или передаешь массив, содержащий объекты, то создается копия массива, хранящая указатели на те же самые объекты.</p>

<p>На первый взгляд, это странно, но в 99% случаев именно это и требуется. Ведь объект обычно представляет какую-то сущность. Если у нас будет много копий одного объекта, то трудно будет понять, в какой из них актуальные данные. </p>

<p>Если требутся сделать именно независимую копию, можно использовать <dfn>оператор клонирования объекта</dfn> <code>clone</code>, который сделает новую, независимую копию:</p>

<pre><code>$b = clone $a;
</code></pre>

<p>Если объект содержит в своих полях другие объекты, то они не клонируются, а лишь копируется указатель на них. Если тебе это не нравится, ты можешь определить "магический" метод <code>__clone</code> в классе. Он будет вызван после клонирования, и в нем ты можешь вручную склонировать дочерние объекты. Подробнее это описано в мануале.</p>

<p>Повторим еще раз: новый объект создается <strong>только</strong> операторами <code>new</code> или <code>clone</code>. Во всех остальных случаях вроде присваивания <code>$a = $b</code> или передачи в функцию просто копируется ссылка на существующий объект.</p>

<p>Официальный мануал по копированию и клонированию: <a href="http://php.net/manual/ru/language.oop5.cloning.php">http://php.net/manual/ru/language.oop5.cloning.php</a></p>

<h2>Аггрегация</h2>

<p>Аггрегация - это когда мы храним один объект в свойстве другого объекта. Ее можно использовать, например, когда у нас есть 2 разных класса с похожим набором свойств, или один класс с повторяющимися свойствами. Чтобы не дублировать их, мы можем вынести их в отдельный класс. </p>

<p>Допустим, мы делаем приложение для хранения итогов футбольного турнира. Мы хотим объявить класс Матч (Game), хранящий информацию о том, когда прошла встреча, какие команды играли и какой был итог. Можно попробовать написать такой код: </p>

<pre><code>class Game
{
    public $date;     // Дата встречи

    public $nameA;    // Название первой команды
    public $countryA; // Страна первой команды
    public $playersA; // Массив с именами игроков 
    public $scoreA;   // Число очков, набранное первой командой

    public $countryB; // Страна второй команды
    public $nameB;
    public $playersB;
    public $scoreB;  
}
</code></pre>

<p>Здесь есть такие недостатки: во-первых, у нас есть 2 набора однотипных полей. Во-вторых, если команда провела несколько матчей, то в каждом объекте, представляющем итоги матча, мы дублируем одни и те же данные. </p>

<p>Можно решить проблему, сделав Команду отдельной сущностью, и объявив для нее отдельный класс. А в объекте класса Game просто хранить объекты-команды, участвовавшие во встрече. Вот как это будет выглядеть: </p>

<pre><code>class Team
{
    public $name; // название команды
    public $players;
    public $country;
}

class Game
{
    // объект класса Team, представляющий первую команду
    public $teamA; 
    // вторая команда
    public $teamB; 
    // дата и итоги встречи
    public $date;
    public $scoreA;
    public $scoreB;
}
</code></pre>

<p>Заметь, что мы не стали выносить поле с числом очков в класс Team, так как это свойство Матча, а не Команды и одна Команда может участовать в нескольких Матчах с разным счетом.</p>

<p>Кроме аггрегации есть еще другой вариант хранения одних объектов внутри других - <em>композиция</em>. Она отличается от аггрегации тем, что внутренние объекты не могут существовать отдельно от внешнего,  создаются самим внешним объектом в конструкторе или методах (а не где-то снаружи), и уничтожаются вместе с родителем. В нашем примере мы можем создать Команду, не участвовавшую ни в одном Матче, а при уничтожении Матча (например, если результаты отменили) Команды продолжают существовать. Потому у нас аггрегация.</p>

<p>Примером композиции может быть Университет и Факультеты или Компания и Отдел в ней: факультет не может существовать без университета, сам по себе.</p>

<p>Википедия: <a href="https://ru.wikipedia.org/wiki/%D0%90%D0%B3%D1%80%D0%B5%D0%B3%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)">композиция и аггрегация</a></p>

<p>Я знаю, тебе уже хочется решить новую задачу на ООП, но подожди еще немного. </p>

<h2>Наследование классов</h2>

<p>Наследование позволяет создать новый класс не с нуля, а расширив уже существующий. Мы берем созданный ранее класс (<em>класс-предок</em>) и добавляем или переопределяем в нем поля и методы. Для этого используется такой синтаксис: </p>

<pre><code>class ИмяНаследника extends ИмяПредка { ... }
</code></pre>

<p>Ну например: </p>

<pre><code>class A 
{
    public $a = 1;
    public $b;
    public function getSomething() { ... } 
}

class B extends A 
{
    public $a = 10;
    public $c;
    public function getSomething() { ... } 
}
</code></pre>

<p>Класс <code>A</code> (<em>предок</em> или <em>суперкласс</em>) содержит поля <code>a</code> и <code>b</code>. Класс <code>B</code> (<em>потомок</em>, <em>наследник</em>, <em>подкласс</em>) наследует от него поля <code>a</code> и <code>b</code> (при этом переопределив значение по умолчанию для <code>a</code>) и содержит дополнительное поле <code>c</code>. Также, он переопределяет метод <code>getSomething()</code>.</p>

<p>Нельзя наследовать что угодно от чего угодно. Наследование должно применяться только для однотипных сущностей. Например, класс Банк можно унаследовать от класса Организация (так как банк - это вид организации), а вот унаследовать класс Работник от Организации нельзя. Также, нельзя унаследовать Организацию от Банка, так как Организация - это более широкое понятие. Сам PHP конечно не проверяет что ты наследуешь, но люди, которые будут читать код, во втором случае запутаются.</p>

<p>Наследуются все поля и методы, отказаться или удалить часть из них нельзя, можно только переопределить. Согласно <a href="http://x-twig.ru/blog/liskov-substitution-principle/">принципу подстановки Лисков</a> (это фамилия, а не название инопланетной расы) должна обеспечиваться совместимость - объект класса-наследника можно использовать в коде вместо объекта класса-предка, а при удалении полей совместимость бы нарушилась. Если ты переопределяешь метод, то список его аргументов и тип возвращаемого значения должны быть совместимы с одноименным методом в классе-предке.</p>

<p>Когда ты переопределяешь метод, ты можешь захотеть вызвать одноименный метод класса-предка. Если ты напишешь </p>

<pre><code>class B extends A 
{
    public function doSomething()
    {
        $x = $this-&gt;doSomething();
        ...
</code></pre>

<p>то вызовешь сам себя и получишь вечный цикл, программа зависнет (пока не упрется в ограничение на число рекурсивных вызвовов функций). В данном случае надо написать довольно странную конструкцию <code>parent::doSomething()</code>:</p>

<pre><code>public function doSomething()
{
    $x = parent::doSomething();
    ...    
</code></pre>

<p>Рассмотрим пример, где можно применить наследование. Если мы делаем тест, то у нас могут быть разные типы вопросов:</p>

<ul>
<li>вопрос с выбором одного ответа из указаннх вариантов (имеет свойства: текст вопроса, варианты ответа, правильный вариант)</li>
<li>вопрос с вводом числа (имеет свойства: текст вопроса, правильный ответ, допустимое отклонение от правильного вартианта)</li>
</ul>

<p>Если мы захотим описать оба вида вопросов одним классом, то столкнемся с тем, что часть полей лишняя - например в вопросе с вводом числа поле "варианты ответа" не нужно. Решить проблему можно, сделав 3 класса: общий для любых типов вопросов (назовем его "абстрактный вопрос", AbstractQuestion) и 2 конкретных класса для разных типов вопросов: </p>

<pre><code>// Базовый класс, содержит поля используемые 
// во всех видах вопросов
class AbstractQuestion
{
    public $text;
}

// Вопрос с выбором вариантов
class ChoiceQuestion extends AbstractQuestion
{
    public $options; // варианты ответа
    public $correntOption; // правильный вариант        
}

// Вопрос с вводом числа
class NumericQuestion extends AbstractQuestion
{
    public $answer; // ответ
    public $deviation; // допустмая погрешность
}
</code></pre>

<p>Как видишь, эта схема хорошо расширяема - мы можем создавать новые типы вопросов, добавляя классы. Наследование имеет и недостатки: </p>

<ul>
<li>нельзя поменять тип вопроса - надо создавать новый объект другого класса, что не очень логично (ведь мы не создаем новый вопрос - почему же мы создаем новый объект?). Эту проблему можно попробовать решить, применив композицию.</li>
<li>наследовать можно только однотипные сущности</li>
</ul>

<p>Также, при наследовании есть правило: класс-предок не должен ничего знать о своих наследниках. Он не имеет права обращаться к полям или методам, которые появляются только в наследниках и которых нет в нем самом. Это логично: ведь кто-то сделать еще одного наследника и не добавить туда эти поля.</p>

<p>Потому оно используется не так часто. Мануал: <a href="http://php.net/manual/ru/language.oop5.inheritance.php">http://php.net/manual/ru/language.oop5.inheritance.php</a></p>

<h2>Абстрактные классы и методы</h2>

<p>В примере выше, у нас есть один класс, объекты которого создавать нет смысла - это AbstractQuestion. Он содержит текст вопроса, но не содержит ответа и потому бесполезен. Такой классы нужно помечать как <em>абстрактный</em>. Это делается добавлением слова <code>abstract</code> в определение класса: </p>

<pre><code>abstract class AbstractQuestion 
{
    ...
</code></pre>

<p>Добавляя слово, ты информируешь всех, кто будет читать твой код. Также, это защищает тебя от неточностей: если ты попытаешься создать объект абстрактного класса, то PHP откажется это делать и выведет соответствующую ошибку. Абстрактный класс - это класс, объекты которого создавать нельзя. Он нужен только как основа для наследования.</p>

<p>Давай посмотрим на эти 3 класса еще раз. Хорошо бы добавить в них метод для проверки ответа, который получает ответ и сообщает, правильный он или нет. Очевидно, что способ проверки будет разный для разных видов вопросов, потому в каждом классе будет свой вариант метода. Попробуем дописать методы проверки в классы ChoiceQuestion и NumericQuestion:</p>

<pre><code>class ChoiceQuestion
{
    ...
    public function checkAnswer($answer)
    {
        ...
</code></pre>

<p>Мы создаем 2 метода в разных классах с одинаковым названием <code>checkAnswer</code>. Вроде, мы решили задачу, но тут есть такие недостатки: </p>

<ul>
<li>это именно 2 разных, никак не связанных друг с другом метода, хотя очевидно что связь есть и правильнее было бы определить этот метод в классе-предке AbstractQuestion, а в наследниках переопределить. Но непонятно, что можно написать в предке - ведь там не хранится правильный ответ.</li>
<li>если кто-то захочет создать новый тип вопроса и сделает еще один класс-наследник, он может забыть сделать в нем метод <code>checkAnswer</code></li>
</ul>

<p>Обе эти проблемы можно решить, добавив в класс AbstractQuestion <em>абстрактный метод</em>. Это метод, у которого есть только заголовок, но нет тела. Что-то вроде недоделанной заготовки. Классы-наследники обязаны релизовать (переопределить) такой метод, иначе PHP выдаст ошибку. Вот как это выглядит: </p>

<pre><code>class AbstractQuestion
{
    ...
    // метод, проверяющий ответ на вопрос
    abstract function checkAnswer($answer);
    ...
</code></pre>

<p>Мануал по теме: <a href="http://php.net/manual/ru/language.oop5.abstract.php">http://php.net/manual/ru/language.oop5.abstract.php</a></p>

<h2>Задача</h2>

<p>Отдохнем немного от теории, решив задачку.</p>

<blockquote>
  <p>Доработай программу вывода вопросов и проверки ответов, добавив в нее тип вопросов с вводом числа. Ну например, "чему равна скорость света в км/с", "чему равно число Пи", и тд. Тебе придется создать несколько классов для разных типов вопросов. </p>
  
  <p>В ходе ее решения у тебя может возникнуть желание определить, объект какого именно класса перед тобой. Не делай так. Вместо этого, вынеси код, который должен вести себя по-разному для разного типа вопросов (например, вывод вопроса или проверка ответа) в абстрактные методы.</p>
  
  <p>Программа не должна полагаться на то, что существует всего 2 вида вопросов. Она должна позволять добавлять новые виды вопросов, не трогая существующие классы.</p>
</blockquote>

<h2>Модификаторы доступа и инкапсуляция</h2>

<p>Раньше мы всегда писали перед полями и методами слово <code>public</code>. Это слово определяет откуда можно обращаться к полю или вызывать метод, в данном случае - из любого места кода, ограничений нет. Вместо него можно также указывать другие варианты - <code>protected</code> или <code>private</code>.</p>

<p><code>private</code> разрешает обращение к полю или методу только внутри того же класса. <code>protected</code> - внутри того же класса и всех его наследников (но не предков, так как предок не должен знать ничего о наследниках - помнишь?). Заметь что разграничение идет именно на уровне классов, а не объектов: один объект может обратиться к private полю другого, если они относятся к одному классу.</p>

<p>На первый взгляд непонятно, зачем это нужно? Зачем делать лишние ограничения и усложнять себе жизнь? Ответ в том, что как раз отсутствие ограничений усложняет жизнь программисту.</p>

<p>Во-первых, если ты хочешь использовать какой-то класс, и изучаешь его код, то ты можешь смело пропускать private и protected элементы в нем - ты все равно не можешь к ним обращаться. Получается, тебе надо изучать меньший объем кода - только публичную часть класса. </p>

<p>Во-вторых, если поле имеет тип public то его можно менять из любого места кода. И представь, что тебе надо разобраться откуда в нем появляется неправильное значение - тебе придется делать поиск по всему коду программы, а реальные приложения могут быть очень большими по объему. В случае, если поле имеет тип private, тебе придется изучить только один класс. </p>

<p>Ну и наконец если ты пишешь какой-то класс, а другие им только пользуются, то с помощью public/private ты можешь определить - к каким полям и методам имеешь доступ только ты и таким образом защититься от того, что кто-то запишет в них что-то неправильное. Ты можешь сделать вообще все поля private, в таком случае снаружи можно будет вызывать только методы, а в методе ты можешь поставить проверку на неправильное значение и отказываться его принимать. Ну например если мы пишем класс Работник, а в нем метод для задания его зарплаты, мы можем принимать только неотрицательное число: </p>

<pre><code>private $salary = 0; // зарплата

public function setSalary($salary)
{
    if ($salary &lt;= 0) {
        throw new Exception("Зарплата должна быть больше нуля");
    }

    $this-&gt;salary = $salary;
}
</code></pre>

<p>Так как поле salary приватное, и запись в него возможна только через метод setSalary, то мы гарантируем что в нем не появится некорректное значение. Странная конструкция <code>throw new ...</code> - это выброс исключения, которая выводит сообщение об ошибке и завершает программу. О них подробнее я напишу позже.</p>

<p>Такой подход, когда класс скрывает (инкапслирует) в себе логику работы с данными и сами данные, а наружу выставляет только небольшое число публичных методов, называется <em>инкапсуляция</em>. Пользователю этих методов не важно, как класс устроен внутри, как он хранит данные, ему достаточно вызвать нужный метод, чтобы получить результат.</p>

<p>Это упрощает понимание кода: тебе не надо читать и разбирать код класса, достаточно прочитать название метода (и может быть комментарий к нему). Также, это упрощает изменение кода: если какое-то свойство имеет уровень private то доступ к нему возможен только из того же класса и тебе не надо бегать по всему коду и смотреть что там с этим свойством делается, тебе достаточно просмотреть один файл с этим классом. </p>

<p>Инкапсуляция это хорошо. Так как весь код, который занимается одной задачей, оказывается заключен внутри одного класса. Противоположный случай это когда код (или знание о его внутреннем устройстве) вылезает из класса и размазывается по всей программе.</p>

<p>Если проводить аналогии, то можно представить кофе-машину. Ты нажимаешь кнопку (=вызываешь публичный метод) и получаешь кофе (=результат вызова этого метода), при этом ты не видишь что происходит внутри нее и тебе не надо в этом разбираться.</p>

<p>Ссылка: <a href="http://php.net/manual/ru/language.oop5.visibility.php">http://php.net/manual/ru/language.oop5.visibility.php</a></p>

<h2>Тайп-хинты</h2>

<p>Тайп хинты позволяют указать, что аргумент функции должен быть определенного типа (например быть объектом определенного класса или его наследника). Тайп хинт делает код понятнее (так как видно, какого типа переменная) и надежнее (так как PHP не позволит передать что-то неразрешенное и ты сразу увидишь ошибку). Используй их везде. </p>

<p>Вот пример заголовка функции с тайп-хинтами: </p>

<pre><code>function doSomething(SomeClass $a, array $b)
</code></pre>

<p>Это значит, что в качестве <code>$a</code> можно передать только объект класса <code>SomeClass</code> или его наследника (помнишь принцип подстановки со странной фамилией? он говорит о том, что объект класса-наследника можно использовать вместо объекта класса-предка). А в качестве <code>$b</code> - любой массив.</p>

<p>В PHP5 нельзя указывать тайп-хинты для строк или чисел. Если ты напишешь <code>int</code> или <code>string</code> - то PHP подумает что это такое имя класса. А вот в PHP7 - будет можно. Кроме того, там можно будет указывать тайп-хинты еще и для указания типа результата функции (а когда-нибудь и типы для полей объекта). Заживем!</p>

<p>Вот пример, работающий в PHP7:</p>

<pre><code>// Функция, принимающее целое число (или строку с целым числом)
// и возвращающую на выходе объект класса SomeClass или 
// его наследника
function doSomething(int $a):SomeClass
</code></pre>

<p>Мануал: <a href="http://php.net/manual/ru/language.oop5.typehinting.php">http://php.net/manual/ru/language.oop5.typehinting.php</a></p>

<h2>Константы</h2>

<p>В PHP можно объявлять константы в классе (разумеется, они должны иметь к нему какое-то отношение). Их можно использовать для обозначения одного из вариантов значения свойства. Ну например, если мы пишем приложение для обработки заявок и жалоб от пользователей, и у нас в классе Заявка есть поле "статус" (в каком состоянии заявка: ведется работа, выдан отказ, удовлетворена, передана в другую организацию), то на первый взгляд, можно использовать для этого обычные строки: </p>

<pre><code>$report-&gt;status = 'Удовлетворена';
</code></pre>

<p>Но этот подход имеет недостатки: </p>

<ul>
<li>если ты опечатеашься в статусе, то такую ошибку будет трудно заметить, но программа начнет работать неправильно </li>
<li>нигде не документирован полный список возможных статусов. Чтобы понять, надо изучать весь код программы, а она может быть большой.</li>
</ul>

<p>Решение - сделать в классе Заявки константы, обозначающие разные статусы. Если ты опечатаешься в имени константы, PHP сообщит тебе об ошибке, и нетрудно увидеть какие вообще статусы бывают. Вот пример кода: </p>

<pre><code>class Report
{   
    const STATUS_NEW = 1; // пока не проверена
    const STATUS_WORKING = 2;   // ведется работа
    const STATUS_REJECTED = 3;  // отказ
    const STATUS_DONE = 4; // выполнена
    ...
}

$report-&gt;status = Report::STATUS_DONE;  
</code></pre>

<p>Имена констант пишут заглавными буквами, разделяя слова подчеркиваниями.</p>

<p>Мануал: <a href="http://php.net/manual/ru/language.oop5.constants.php">http://php.net/manual/ru/language.oop5.constants.php</a></p>

<h2>Исключения</h2>

<p>Исключения позволяют сообщить о неожиданной ситуации в программе. Ну например, в метод, задающий зарплату работника, передано отрицательное число. Это говорит о том, что в программе скорее всего ошибка, и необходимо подождать пока программист разберется и исправит ее. </p>

<p>Урок по исключениям: <a href="https://github.com/codedokode/pasta/blob/master/php/exceptions.md">https://github.com/codedokode/pasta/blob/master/php/exceptions.md</a></p>

    <h2>Официальный мануал по ООП</h2>

    <p><a href="http://php.net/manual/ru/language.oop5.php" 
        target="_blank">http://php.net/manual/ru/language.oop5.php</a></p>

    <p>Почитать про ООП можно также в книгах:</p>

    <ul>
        <li> Профессиональное программирование на PHP Джордж Шлосснейгл</li>
        <li>Мэтт Зандстра — PHP: Объекты, шаблоны, методики программирования</li>
    </ul>

    <h2>Задачи</h2>

    <p>Если ты дошел до этого абзаца, ты наверно чувствуешь себя другим 
        человеком. Еще вчера ты писал примитивные программы, а сегодня ты с 
        легкостью можешь решить любую проблему, построив 
        красивую и стройную модель из классов. Ведь именно 
        объектно-ориентированное программирование - это то, что позволяет писать
        большие и сложные программы. Большинство современных приложений, вроде  
        Microsoft Word, Photoshop или Google Maps построены с использованием ООП.</p>

    <p>Прекрасно! Пришло время перейти от разминочных к настоящим задачам. </p>

    <h2>Задача про компанию «Вектор»</h2>

    <p>В большой международной перспективной компании «Вектор» есть 4 департамента: департамент закупок, продаж, рекламы и логистики. В этих 4 департаментах работают менджеры (ме), маркетологи (ма), инженеры (ин) и аналитики (ан). </p>

    <p>Менеджер получает 500 тугриков в месяц, выпивает 20 литров кофе и производит 200 страниц отчетов в месяц</p>
    <p>Маркетолог — 400 тугриков, 15 литров кофе и 150 страниц отчетов</p>
    <p>Инженер — 200 тугриков, 5 литров кофе и 50 страниц чертежей</p>
    <p>Аналитик — 800 тугриков и 50 литров кофе и 5 страниц стратегических исследований</p>

    <p>Кроме того, все сотрудники бывают 3 рангов: первого, второго и третьего. Сотрудник второго ранга получает на 25% больше, чем первого, а сотрудник 3-го ранга - на 50% больше, чем первого. </p>

    <p>Для удобства, мы будем обозначать должность сокращенно, например менеджер 2-го ранга = ме2.</p>

    <p>Вот состав департаментов:</p>

    <pre><code>Департамент закупок: 9×ме1, 3×ме2, 2×ме3, 2×ма1 + руководитель департамента ме2
Департамент продаж: 12×ме1, 6×ма1, 3×ан1, 2×ан2 + руководитель ма2
Департамент рекламы: 15×ма1, 10×ма2, 8×ме1, 2×ин1 + руководитель ма3
Департамент логистики: 13×ме1, 5×ме2, 5×ин1 + руководитель ме1</code></pre>

<p>Руководитель получает на 50% больше, чем обычный сотрудник того же уровня, пьет в 2 раза больше кофе, и не производит отчетов, чертежей или стратегических исследований.</p>

<p>Задание: напиши программу для учета расходов и результатов работы всего дружного коддектива компании «Вектор». Программа должна вывести: </p>

<ul>
<li>Число сотрудников в каждом департаменте 
<li>Расходы на зарплату и на кофе по каждому департаменту и в сумме
<li>Число страниц документов и отчетов, которые производят каждый департамент и в сумме
<li>Посчитать средний расход тугриков на одну страницу 
</ul>
Вывести результаты можно примерно так: 

<pre><code>
Департамент   сотр.     тугр.     кофе   стр.   тугр./стр.
-----------------------------------------------------------------------
Закупок          25     45040      100     10        450.4
Продаж           14     56000      150     12        560
....

Среднее        23.5     35600      170     15        500
Всего           120    120000      220     34       2000
</code></pre>

Программа должна быть сделана так, чтобы исходные данные о сотрудниках можно было легко поменять.
Должна быть возможность добавлять новые профессии, не меняя старые классы.
</p>

    <h3>Дополнительные примечания и советы</h3>

    <p>На первый взгляд, наверно, задача кажется неприступной. Но не 
        стоит паниковать! Держи подсказки.</p>

    <p>Когда ты решаешь задачу на ООП, ты должен ответить на вопросы: </p>

    <ul>
        <li>какие есть сущности, для которых мы сделаем классы? (Сотрудник и 
            Департамент, может быть еще Компания?)</li>
        <li>какие у них есть свойства (у Сотрудника есть ранг, базовая ставка,  
            профессия, является ли боссом). Потребление кофе или зарплата не 
            являются свойствами так как они вычисляются из других свойств и 
            хранить их не надо.</li>
        <li>что мы хотим от них получить (какие у них должны быть методы). 
            Например мы хотим узнать сколько сотрудник заработал или сколько он 
            пьет кофе. От департамента мы наверно хотим получить сколько всего 
            выпито кофе и заплачено денег.</li>
        <li>как сущности связаны? Очевидно, Сотрудник работает в каком-то 
            Департаменте.</li>
    </ul>

    <p>Не путай базовую ставку в профессии и итоговую зарплату сотрудника - 
        это разные вещи.</p>

    <p>Возможно, тут стоит сделать не один класс 
        Сотрудник, а 4 класса: Инженер, Менеджер, и т.д. Тогда мы можем легко менять 
        правила расчета зарплаты или кофе для каждой профессии. Естественно, 
        копипастить одинаковый код в 4 класса  не надо — создай базовый абстрактный 
        класс Сотрудник и унаследуй от него 4 класса-профессии. Правда этот подход 
        имеет недостаток: в этом случае мы не можем поменять профессию сотрудника 
        (чтобы ее возможно было менять, надо сделать отдельно класс Сотрудник, и 
        отдельно же классы для каждой профессии. Это усложнит код, но сделает его
        более универальным).</p>

    <p><a href="http://php.net/manual/ru/language.oop5.inheritance.php" target="_blank">
        Наследование (мануал)</a> позволяет создавать класс не с нуля, 
        а расширяя сущеcтвующий класс. Наследовать можно только однотипные сущности, 
        например унаследовать Менеджера от Сотрудника можно, а допустим Танк от Инженера - 
        неправильно.
    </p>

    <p><a href="http://php.net/manual/ru/language.oop5.abstract.php" target="_blank">
        «Абстрактный»</a> — это класс, объект которого нельзя создать. Он предназначен для 
        наследования от него других классов.
    </p>

    <p>Также, ты должен для всех полей и методов расставить модификаторы доступа 
        (pubic, private, protected - они определяют, откуда можно обращаться к 
        полю или методу). Ты должен подумать логически и для каждого поля/метода 
        определить: это часть кода, которая относится к внутренней логике класса
         и не должна быть доступна снаружи, или же это часть кода, которая должна 
         быть доступна. Ну к примеру, в Департаменте метод 
         <code>посчитатьОбщиеЗатратыНаЗарплату()</code> должен быть публичным - 
         для этого мы  и пишем класс, чтобы считать затраты. </p>

    <p>В общем, чем  меньше публичных свойств и методов, тем лучше. Ведь когда другой
         разработчик или ты сам захочет использовать класс, он будет смотреть только
          на публичные элементы, и чем их меньше, тем проще разобраться как класс 
          работает. Но не стоит закрывать вообще все: надо думать, является ли метод 
          частью внутренней логики класса или он предназначен для выдачи полезной 
          информации. </p>
    
    <p>Когда ты проектируешь класс, ты можешь представить себе что ты делаешь некую 
    коробочку, из которой торчат переключатели и провода. Публичные свойства 
    и методы - это то, что ты разрешаешь использовать другим программистам. 
    Приватное - это то, что скрыто внутри коробки и что они трогать не должны.</p>

    <h2>ООО Вектор и антикризисные меры</h2>

    <p>Ты наверно думал, что твои мучения закончились? Нет, не так быстро. Пришло
        время проверить, соответствует ли твой код принципам ООП? Гибок ли он 
        и легко ли поддается изменениям?</p>

    <p>Пока ты решал задачу по выводу отчета о сотрудниках и департаментах, 
        разразился мировой экономический кризис. Доходы компании начали снижаться, 
        и совет директоров поставил перед руководством задачу принять меры. 
        Менеджеры 3-го ранга, блестящие выпускники топовых экономических вузов 
        столицы, быстро смогли разработать три альтернативных антикризисных решения:</p>

    <ol>
        <li>Сократить в каждом департаменте 40% (округляя в большую сторону) инженеров, 
        преимущественно самого низкого ранга. Если инженер является боссом, вместо него 
        надо уволить другого инженера, не босса.</li>

        <li>Увеличить в целях стимуляции умственной деятельности базовую ставку 
        аналитика с 800 до 1100 тугриков, а количество выпиваемого им кофе с 
        50 до 75 литров. В тех департаментах, где руководитель не является 
        аналитиком, заменить его на аналитика самого высшего ранга из этого 
        департамента (а бывшего руководителя вернуть к обычной работе)</li>

        <li>В каждом департаменте повысить 50% (округляя в большую сторону) 
        менеджеров 1-го и 2-го ранга на один ранг с целью расширить 
        их полномочия.</li>
    </ol>

    <p>Совет директоров в затруднении: какой путь выбрать? Помоги им с этим, 
    распечатав прогноз по потреблению и расходам (аналогичный тому что 
    требуется в первой части задачи) после принятия каждой из мер.</p>

    
    <h2>Задача про кошек-мышек</h2>

    <p>Есть поле размером N×N (задается в переменной), на нем есть несколько 
        кошек и несколько мышек (расставляются случайно). </p>

    <p>Мышка может ходить на одну клетку по горизонтали или вертикали, 
        видит карту в квадрате 9×9 (сама мышка в центре этого квадрата) и 
        старается убежать, если видит кошку (что делать, если мышка видит 
        несколько кошек с разных сторон, решать тебе). Если не видит — 
        просто идет в случайно выбранную сторону или куда-то еще. Если некуда 
        ходить, все клетки вокруг заняты — стоит на месте.</p>

    <p>Кошка ходит на одну клетку по горизонтали, вертикали, диагонали в любую 
    сторону, и видит всю карту. Если кошка ходит на клетку с мышкой, то она 
    ее ловит и съедает. Правда, если на соседних по горизонтали, вертикали, 
    диагонали с мышкой клетках есть еще 2 мышки, то кошка не может съесть 
    мышку и встать на ее клетку (мыши объединяются и защищают друг друга).</p>

    <p>Если кошка съела мышку, ей надо отдохнуть, и 1 ход она после этого 
    пропускает. Если кошка бегала 8 ходов подряд, то она тоже засыпает и 
    пропускает 1 ход. Каждый ход, сначала ходят все мышки и только 
    потом все кошки.</p>

    <p>Напиши программу, которая рассчитает, что происходит в течение, 
    например, первых 20-30 ходов и выводит состояние игры на каждом ходе, 
    например, так (@ = спящая кошка):</p>


<pre><code>...@....    ход: 1 
..2...3.    кошек: 2
........    мышек: 4
....К...
1.......
......4.</code></pre>


    <p>Потом можно будет добавить еще одного персонажа, Собаку. Собака прыгает на 2 клетки в 1 из 8 направлений, если там есть свободная клетка. Собака ни за кем не охотится, так как она глупая, и просто бегает в случайном порядке. Кошка не может сходить на соседнюю с собакой клетку, так как боится ее. Мыши могут этим пользоваться.</p>

    <h3>Подсказки по задаче про кошек-мышек</h3>

    <p>Вот, как можно реализовать алгоритм выбора оптимального хода
    для любого животного:</p>

    <ul>
        <li>сгенерировать список всех возможных ходов, включая 
            &laquo;стоять на месте&raquo;</li>
        <li>оценить каждый ход в баллах с помощью <em>оценочной функции</em>, 
            которая принимает на вход вариант хода и выдает оценку в баллах</li>
        <li>выбрать ход с наибольшим числом баллов</li>
        <li>сделать его</li>
    </ul>

    <p>ВариантХода кстати вполне можно сделать объектом, мы же ООП изучаем.</p>

    <p>Заметь что этот алгоритм подходит к любому животному, единственное, 
        что различается - это оценочная функция и функция генерации списка 
        возможных ходов (так как разные животные ходят по разному). </p>

    <p>Саму оценочную функцию можно написать так: определяем <em>факторы</em>, которые 
        влияют на поведение животного, оцениваем их в баллах и складываем с 
        весом (более важные факторы имеют больший вес), чтобы получить итоговую оценку.
        К примеру, для мыши факторы могут быть такие:</p>

    <ul>
        <li>Расстояние от клеточки хода до ближайшей кошки. Если рядом с клеткой 
            стоит кошка - это плохой ход, если же наоборот рядом их нет - хороший.</li>
        <li>Близость к краям или углам: в них мышку легко зажать</li>
    </ul>

    <p>Также важно расставить правильный вес для этих факторов, чтобы например 
        ход в угол все же был выгоднее, чем ход навстречу кошке.</p>

    <p>Так как поле состоит из клеточек, у тебя может появиться желание сделать 
    двухмерный массив для хранения животных. Не советую так делать, ведь этот 
    массив надо будет поддерживать в актуальном состоянии. Проще хранить обычный
    одномерный массив животных, находящихся на карте.</p>

    <div class="b-next-page">
    <span class="m-label">дальше:</span>
    <span class="m-link"><a href="../l1/reading-list.html">Учимся писать веб-приложения</a>&nbsp;&rarr;</span>
</div>    <div class="b-epilog">
        <p>-----</p>
                    <p><strong>Куда вводить код? Что надо скачать?</strong> Читай <a href="../">первый урок</a>.</p>    
                <p><strong>Есть вопросы?</strong> Задай гуглу или автору.</p>
        <p><strong>Нравится урок?</strong> Лайкай, репости, приглашай друзей, пости котов и Канако,
             шли добра, решай задачи, помогай новичкам! Кнопок для лайка нет, кто хочет зарепостить, всегда может сделать это ручками.</p>
        <p><strong>Как связаться с автором?</strong> <span class="spoiler"> Я хочу переодеть его в платье
         школьницы и жениться на нем.</span> Ящик codedokode (кот) gmail.com ждет ваших писем.  А
         <span style="color: #009; text-decoration: underline; cursor: pointer;">вконтактик</span> и 
            <span style="color: #009; text-decoration: underline; cursor: pointer;">фейсбучек</span> ждут ваших лайков.
         Но ответ на банальные вопросы лучше искать в Гугле или на stackoverflow.</p>
        <p><strong>Я решил задачку!!!</strong> Молодец, делай следующий урок</p>
                    <p><strong>Ideone не работает!11</strong> Ну так открой Гугл и найди сайты 
            вроде https://repl.it/languages/php , http://phptester.net/ , 
            http://sandbox.onlinephpfunctions.com/ , 
            http://codepad.org/ или http://www.runphponline.com/ . Не ленись.</p>
        
        <p><strong>Почему так много рекламы?</strong> Всю рекламу
        на сайте ставит юкоз (бесплатный хостинг же), а не я.</p>
        <p>На сайте установлена система Google Analytics (и еще несколько аналогичных систем от юкоза). Данные о твоем IP-адресе, посещаемых страницах, 
        времени посещения отправляются в Google Corporation, США. Хочу знать, кто и зачем сюда заходит. Поверь, 
        другие сайты делают точно так же. Все сайты пишут логи.</p>
    </div>
        
                

        </div>
    </div>        
    <div class="l-sidebar">

        <ul class="b-main-menu vlist">
                                                                                        <li>
                                            <a href="../">Начало</a>
                                    </li>
                                                                                                
                                                    <li><ul class="vlist b-menu-l1">
                                                            <li>
                                            <a href="../l1/variables.html">Переменные</a>
                                    </li>
                                                                                        <li>
                                            <a href="../l1/conditions.html">Условия и игра в кубики</a>
                                    </li>
                                                                                        <li>
                                            <a href="../l1/loops.html">Циклы и айфон в кредит</a>
                                    </li>
                                                                                        <li>
                                            <a href="../l1/arrays.html">Массивы и рулетка</a>
                                    </li>
                                                                                        <li>
                                            <a href="../l1/strings.html">Строки, хакеры и шифровки</a>
                                    </li>
                                                                                        <li>
                                            <a href="../l1/functions.html">Функции и новый айпад</a>
                                    </li>
                                                                                        <li>
                                            <a href="../l1/regexp.html">Регулярные выражения</a>
                                    </li>
                                                                                        <li>
                                            <a href="../l1/finals.html">Повторим?</a>
                                    </li>
                                                                                        <li>
                                            <a href="../l1/mou-ikkai.html">Бонусные задачки</a>
                                    </li>
                                                                                        <li class='active'>
                                            <span>Пасты и ООП                            <ins class="dec-l"></ins><ins class="dec-r"></ins></span>
                                    </li>
                                                                                        <li>
                                            <a href="../l1/reading-list.html">Учим сами</a>
                                    </li>
                                                                                                                            </ul></li>
                                                            <li class='separated'>
                                            <a href="../tsuzuke.html">Что делать дальше?</a>
                                    </li>
                                                                                        <li>
                                            <a href="../i-am-smart.html">Я у мамы умный</a>
                                    </li>
                                
                    </ul>

        <div class="b-block small-font">
            <h2>Что это?</h2>
            
            <p>Это сайт, где собраны простые 
                уроки по языку программирования
                                PHP. 
                                Даже если ты никогда
                не слышал слова 
                «программирование» и учишься
                на филолога, ты можешь 
                попробовать их сделать.
                </p>

            <p>Скачивать и устанавливать тоже
                ничего не надо, делать уроки 
                можно даже с айпада или 
                ведроида.</p>
        </div>

            </div>

    
    
    <script type="text/javascript">

        var SCOPE_PAGE_LEVEL = 3;

        window._gaq = window._gaq || [];
        _gaq.push(['_setAccount', 'UA-34859509-1']);
        _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
        
        /* outbound link click tracking to check whether anyone uses those links */
        (function() {
            function startsWith(str, substr) {
                return str.substr(0, substr.length) == substr;
            }
            
            function addEvent(node, evt, fn) {
                if (node.addEventListener) {
                    node.addEventListener(evt, fn, false);
                } else {
                    node.attachEvent('on' + evt, fn);
                }
            }
        
            var links = document.getElementsByTagName('a');
            var baseUrl = 'http://' + location.host;
            for (var i = 0; i < links.length; i++) {
                var link = links[i];
                
                if (link.href != baseUrl && !startsWith(link.href, baseUrl + '/')) {
                    // Is an external link
                    addEvent(link, 'mousedown', function(ev) { 
                        window._gaq = window._gaq || [];
                        var e = ev || window.event;
                        var link = e.target || e.srcElement;
                        var text = link.innerText || link.textContent || 'no text';
                        if (text.length > 20) {
                            text = text.substr(0, 20) + '…';
                        }
                        var linkInfo = link.href + ' (' +  text + ')';
                        window._gaq.push(['_trackEvent', 'flow', 'link', linkInfo]);
                    });
                }
            }
        })();

        /* poor man's error logger */
        (function () {
            var errorsReported = 0;
            var MAX_ERRORS = 5;
            
            window.onerror = function (text, file, line) {

                if (errorsReported > MAX_ERRORS) {
                    return;
                }

                errorsReported++;

                window._gaq = window._gaq || [];
                var errorInfo = (text || '(no text)') + ' @ ' + (file || '(no file)') + 
                    ', line ' + (line || '(no line)');
                window._gaq.push(['_trackEvent', 'error', 'onerror', errorInfo]);
            };
        })();
    </script>
</body>
</html>
